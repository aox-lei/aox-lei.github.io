title: Python 多进程和多线程的方案
date: 2017-09-22
slug: python/2

## 一、进程
对于电脑来说, 一个任务就是一个进程(Process), 而每个进程可能还要同时做多件事儿, 所以可以通过进程生成新的子进程

## 二、线程
线程是一种轻量级进程, 是程序执行流的最小单元。因为每个进程至少要做一件事儿, 所以每个进程必然有一个最小的进程。

## 三、多任务的模式
### 一、多进程模式
启动多个进程, 每个进程有一个线程去完成。因为python的多线程有GIL锁(全局锁), 在CPU密集型的情况下, 效率可能还不如单线程。
CPU密集型的意思是cpu利用比较高, 大部分需要使用cpu来计算。
### 二、多线程模式
单个进程下, 多个进程去完成。这种情况下只推荐做IO密集型的操作, 比如爬虫
### 三、多进程+多线程模式
启动多个进程, 每个进程下再启动多个线程去完成, 这种在一般项目中都有可能采用, 比如一个项目有多个脚本, 分别启动进程去管理, 而在单个脚本任务中, 又启动多个线程去抓取数据等

## 四、Python 多进程的方式
Python 多进程采用的是multiprocessing, 兼容性好, 可以兼容windows平台
### 一、基本使用
```
from multiprocessing import Process


def f(name):
    print('hello', name)


if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p1 = Process(target=f, args=('lis',))
    p.start()
    p1.start()
    p.join()
    p1.join()

>>> 以上demo会输出
hello bob
hello lis

```

### 二、 join的作用
join的作用是用来阻塞, 增加了time.sleep()来暂停几秒
```
import time
from multiprocessing import Process


def f(name):
    print('hello', name)
    time.sleep(5)


if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p1 = Process(target=f, args=('lis',))
    p.start()
    p1.start()
    p.join()
    p1.join()

>>> 以上demo会输出
hello bob
hello lis
停留5秒以后退出脚本
```

更改脚本以后再看一下效果
```
import time
from multiprocessing import Process


def f(name):
    print('hello', name)
    time.sleep(5)


if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p1 = Process(target=f, args=('lis',))
    p.start()
    p.join()
    p1.start()
    p1.join()

>>> 以上demo会输出
hello bob
停留5秒
hello lis
停留5秒以后退出脚本
```
会发现先输出hello bob后停留了5秒, 才输出hello lis,之后又停留5秒, 才退出脚本。如果没有join, 则出现失误时, 可能会启动了无数个脚本, 而join可以保证, 无论何时, 都同时是这几个脚本。

### 三、进程池(Pool)
需要运行大量的进程时使用, 在使用时指定一个运行的进程数量, 当有进程退出的时候, 再启动进程池。
```
from multiprocessing import Pool
import time


def fun1(t):
    print('this is fun1', time.ctime())
    time.sleep(t)
    print('fun1 finish', time.ctime())


def fun2(t):
    print('this is fun2', time.ctime())
    time.sleep(t)
    print('fun2 finish', time.ctime())


if __name__ == '__main__':
    a = time.time()
    pool = Pool(processes=3) # 同时可以启动三个进程
    for i in range(3, 8):
        pool.apply_async(fun1, (i,))

    pool.close() # close()以后, 就不可以加入新的进程
    pool.join() # 进程池阻塞
    b = time.time()

    print('finish', b - a)
```

## 五、多线程的方式
python的多线程用的是threading模块

### 一、基本使用
```
import time
import threading


def run(num):
    print(num)
    time.sleep(5)


_thread = []
for i in range(5):
    _thread.append(threading.Thread(target=run, args=(i,)))

for _t in _thread:
    _t.start()

for _t in _thread:
    _t.join()

>>> 以上demo输出
0
1
2
3
4
5
```
